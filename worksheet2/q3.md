### Alice and Bob share a secret 128-bit key k that they will use to authenticate every message that they send. Every time Alice wants to send a message m to Bob, she breaks the message m up into blocks m1, m2, . . . , mn and outputs the tag for each block t1, t2, . . . , tn, where ti = MACk(mi, i) for all i âˆˆ {1, . . . , n}. Alice sends m1, m2, . . . , mn and t1, t2, . . . , tn to Bob. 1. Write down the verification algorithm for this scheme

verification on Bob's end, takes each m1, encrypt it using secret key MACk(mi, i) and if it is the same as the tag, then verification success.

### Prove that it is not a secure MAC

m0 = a0,...,an
m1 = b0,...,bn

The MAC challenger will return
t0 = MAC(k, a0), . . . , MAC(k, an) and t1 = MAC(k, b0), . . . , MAC(k, bn).

Adversarial Strategy Queries: 

The adversary queries two messages: 

ğ‘š0 = ( ğ‘0, ğ‘1, â€¦ , ğ‘ğ‘› ) 

ğ‘š1 = ( ğ‘0 , ğ‘1 , â€¦ , ğ‘ğ‘› ) 

Forgery: 

The adversary constructs a new message: ğ‘š = ( ğ‘0 , ğ‘1 , ğ‘2 , ğ‘3 , â€¦ ) 

The tag ğ‘¡ = ( MAC ğ‘˜ ( ğ‘0 , 1 ) , MAC ğ‘˜ ( ğ‘1 , 2 ) , MAC ğ‘˜ ( ğ‘2 , 3 ) , MAC ğ‘˜ ( ğ‘3 , 4 ) , â€¦ ) 

Verification: Bob verifies the message ğ‘š m and tag ğ‘¡ t using the algorithm Ver ( ğ‘˜ , ğ‘š ğ‘– , ğ‘¡ ğ‘– ) = accept Ver(k,m i â€‹ ,t i â€‹ )=accept for all ğ‘– i. Since ğ‘¡ t consists of valid tags for the corresponding blocks of ğ‘š m, verification succeeds, even though ğ‘š m was never queried to the MAC. This is because each tag was generated independently based on index and message. There's no global context